{"meta":{"title":"spring-cloud","subtitle":null,"description":null,"author":"zzh","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"spring-boot快速入门","slug":"spring-boot","date":"2017-07-04T01:28:20.446Z","updated":"2017-07-04T01:58:30.850Z","comments":true,"path":"2017/07/04/spring-boot/","link":"","permalink":"http://yoursite.com/2017/07/04/spring-boot/","excerpt":"传统的spring项目的配置都是基于XML配置的，每次创建一个项目都需要复制粘贴一堆的配置。Spring Boot可以基于Spring轻松创建需要很少配置的项目。","text":"传统的spring项目的配置都是基于XML配置的，每次创建一个项目都需要复制粘贴一堆的配置。Spring Boot可以基于Spring轻松创建需要很少配置的项目。 spring boot 特性1、创建独立的Spring应用程序2、直接嵌入Tomcat，Jetty或Undertow（不需要部署WAR文件）3、提供 ‘starter’ POMs来简化Maven配置4、尽可能自动配置spring5、提供生产就绪功能，如指标，运行状况检查和外部化配置6、绝对没有代码生成，也不需要XML配置","categories":[],"tags":[]},{"title":"RabbitMq快速入门","slug":"rabiitmq","date":"2017-06-08T15:14:12.406Z","updated":"2017-06-09T16:52:17.533Z","comments":true,"path":"2017/06/08/rabiitmq/","link":"","permalink":"http://yoursite.com/2017/06/08/rabiitmq/","excerpt":"RabbitMQ是一个消息代理 - 一个消息系统的媒介。它可以为你的应用提供一个通用的消息发送和接收平台，并且保证消息在传输过程中的安全。","text":"RabbitMQ是一个消息代理 - 一个消息系统的媒介。它可以为你的应用提供一个通用的消息发送和接收平台，并且保证消息在传输过程中的安全。 传统项目中使用RabbitMq配置在pom.xml中添加相关依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt; &lt;version&gt;1.7.3.RELEASE&lt;/version&gt;&lt;/dependency&gt; 新建一个rabbitmq.properties文件 12345spring.rabbitmq.host=192.168.1.2spring.rabbitmq.port=2500spring.rabbitmq.username=testspring.rabbitmq.password=123456spring.rabbitmq.virtual-host=test 读取rabbitmq.properties文件 1234567&lt;bean id=\"propertyConfigurer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:rabbitmq.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; connectionFactory、rabbitTemplate配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Configurationpublic class RabbitMqConfig &#123; // 用户日志队列名称 public static final String COMMON_USER_LOG = \"common_user_log\"; // rabbitmq 端口 @Value(\"$&#123;spring.rabbitmq.port&#125;\") public Integer RabbitPort; // rabbitmq 地址 @Value(\"$&#123;spring.rabbitmq.host&#125;\") public String RabbitHost; // rabbitmq 虚拟主机 （类似mysql 的数据库） @Value(\"$&#123;spring.rabbitmq.virtual-host&#125;\") public String RabbitVirtualHost; // rabbitmq 用户名 @Value(\"$&#123;spring.rabbitmq.username&#125;\") public String RabbitUserName; // rabbitmq 密码 @Value(\"$&#123;spring.rabbitmq.password&#125;\") public String RabbitPassword; @Bean(name = \"connectionFactory\") public CachingConnectionFactory connectionFactory() &#123; CachingConnectionFactory connectionFactory = new CachingConnectionFactory(); connectionFactory.setPort(RabbitPort); connectionFactory.setHost(RabbitHost); connectionFactory.setVirtualHost(RabbitVirtualHost); connectionFactory.setUsername(RabbitUserName); connectionFactory.setPassword(RabbitPassword); return connectionFactory; &#125; @Bean(name = \"rabbitAdmin\") public RabbitAdmin rabbitAdmin(@Qualifier(\"connectionFactory\") CachingConnectionFactory connectionFactory) &#123; return new RabbitAdmin(connectionFactory); &#125; @Bean(name = \"rabbitTemplate\") public RabbitTemplate rabbitTemplate(@Qualifier(\"connectionFactory\") CachingConnectionFactory connectionFactory) &#123; return new RabbitTemplate(connectionFactory); &#125; /** * 定义一个队列 * 业务不复杂，所有队列默认绑定到默认交换名称，因此我们可以在发送中使用队列名称作为路由密钥 * @return */ @Bean public Queue commonUserQueue() &#123; return new Queue(COMMON_USER_LOG); &#125; &#125; 消息发送123456789@Autowiredprivate RabbitTemplate rabbitTemplate;public void sendRabbitMq() &#123; rabbitTemplate.convertAndSend(RabbitMqConfig.COMMON_USER_LOG, \"我是一个RabbitMq消息\"); &#125; 消息接受123456789@Component public class MyService &#123; @RabbitListener（RabbitMqConfig.COMMON_USER_LOG） public void processOrder（String data）&#123; ... &#125;&#125; spring-boot项目中使用RabbitMq在pom.xml中添加相关依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 在application.properties 中加入 123456spring.rabbitmq.host=192.168.1.2spring.rabbitmq.port=2500spring.rabbitmq.username=testspring.rabbitmq.password=123456spring.rabbitmq.virtual-host=test 定义队列 12345678910111213@Configurationpublic class RabbitmqConfig &#123; public static final String COMMON_USER_LOG = \"common_user_log\"; @Bean public Queue commonUserQueue() &#123; return new Queue(COMMON_USER_LOG); &#125;&#125; 发送消息、接受消息和传统spring 项目一样的","categories":[],"tags":[]},{"title":"spring-data-jpa快速入门","slug":"spring-data-jpa","date":"2017-06-06T15:18:06.122Z","updated":"2017-07-14T03:06:35.980Z","comments":true,"path":"2017/06/06/spring-data-jpa/","link":"","permalink":"http://yoursite.com/2017/06/06/spring-data-jpa/","excerpt":"spring-data-jpa是Spring Data的一个子项目，可以极大的简化我们对数据库的操作，我们只需要通过编写一个继承自JpaRepository的接口就能完成数据访问","text":"spring-data-jpa是Spring Data的一个子项目，可以极大的简化我们对数据库的操作，我们只需要通过编写一个继承自JpaRepository的接口就能完成数据访问 项目配置使用SPRING INITIALIZR快速创建一个spring boot项目http://start.spring.io/ 添加依赖Spring-data-jpa 依赖Hibernate。如果对Hibernate有一定了解，可以毫不费力的看懂并上手使用Spring-data-jpa在pom.xml中添加相关依赖 1234&lt;dependency &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 配置数据库连接在application.xml中配置：数据库连接信息。为方便测试加入spring.jpa.properties.hibernate.hbm2ddl.auto=update，可以根据实体类自动创建表结构，实际项目中不推荐使用此配置。 123456spring.datasource.url=jdbc:mysql://localhost:3306/demospring.datasource.username=rootspring.datasource.password=123456spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.jpa.properties.hibernate.hbm2ddl.auto=update 创建实体创建一个User实体，包含id（主键）、name（姓名）、age（年龄）属性，通过ORM框架其会被映射到数据库表中，由于配置了hibernate.hbm2ddl.auto，在应用启动的时候框架会自动去数据库中创建对应的表。 123456789101112131415@Data@Entity@Table(name = \"user\")public class User &#123; @Id @GeneratedValue private Integer id; @Column(nullable = false) private String name; @Column(nullable = false) private Integer age;&#125; 本示例项目中使用了lombok插件，只要是实体类上加上@Data，lombok会自动生成get set方法。 创建数据访问接口创建一个继承JpaRepository的接口 1234public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123; &#125; 该接口继承自JpaRepository，该接口本身已经实现了创建（save）、更新（save）、删除（delete）、查询（findAll、findOne）等基本操作的方法。 123456789101112131415161718192021222324252627282930@Servicepublic class UserService &#123; @Autowired private UserRepository userRepository; public void findUser(Integer userId)&#123; // 根据ID查询 User user = userRepository.findOne(userId); user.setName(\"test\"); // 更新 userRepository.save(user); User user2 = new User(); user2.setName(\"test2\"); user2.setAge(18); // 创建 userRepository.save(user2); // 查询所有 List&lt;User&gt; list = userRepository.findAll(); // 根据实体查询 User u = new User(); u.setId(userId); List&lt;User&gt; list1 = userRepository.findAll(Example.of(u)); // 删除 userRepository.delete(userId); // 查询userId的 User是否存在 userRepository.exists(userId); &#125;&#125; Spring-data-jpa还有一大特性：通过解析方法名创建查询。 12345678910public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123; // 按name查询User User findByName(String name) // 按name和age查询User User findByNameAndAge(String name, Integer age) // 按name或者age查询User User findByNameorAge(String name, Integer age) // 按name模糊查询User User findByNameLike(String name)&#125; 更多规则可以查询官网：https://docs.spring.io/spring-data/jpa/docs/current/reference/html/ @Query查询1234567@Repositorypublic interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123; @Query(\"select u from User u where u.name = ?1\") User findByName(String name);&#125; 原生SQL支持12@Query(value = \"select * from user a where a.age = ?1\",nativeQuery = true)User findUser(String age); @Modifying1234567891011@Repositorypublic interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123; void deleteByName(String name); @Modifying @Query(\"delete from User u where user.name = ?1\") void deleteInBulkByName(String name);&#125; deleteByName将先进行一个查询，然后逐个删除返回的实例deleteInBulkByName将直接执行删除SQL 分页排序1234567891011@Repositorypublic interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123; // 分页排序查询 Page&lt;User&gt; findByAge(Integer age, Pageable pageable); // 只排序查询 List&lt;User&gt; findByAge(Integer age, Sort sort); // 只根据年龄查询 List&lt;User&gt; findByAge(Integer age);&#125; 12345678910111213141516@Servicepublic class UserService &#123; @Autowired private UserRepository userRepository; public void findPage(Integer page,Integer size,Integer age)&#123; Pageable pageable = new PageRequest(page,size,new Sort(Sort.Direction.ASC,\"age\")); Page&lt;User&gt; pageData = userRepository.findAll(pageable); List&lt;User&gt; list = pageData.getContent(); Long count = pageData.getTotalElements(); Integer totalPage = pageData.getTotalPages(); Page&lt;User&gt; pageData2 = userRepository.findByAge(age,pageable); List&lt;User&gt; list2 = userRepository.findByAge(age,new Sort(Sort.Direction.ASC,\"name\")); &#125; 动态SQL继承JpaSpecificationExecutor接口 1234public interface BasicCommunityRespository extends JpaRepository&lt;BasicCommunity, Integer&gt;, JpaSpecificationExecutor &#123; &#125; 完整示例 12345678910111213141516171819202122232425262728293031323334 public List&lt;BasicCommunity&gt; list(String communityName, String communityIds) &#123; return basicCommunityRespository.findAll(getWhereClause(communityName, communityIds)); &#125; private Specification&lt;BasicCommunity&gt; getWhereClause(final String communityName, final String communityIds) &#123; return new Specification&lt;BasicCommunity&gt;() &#123; @Override public Predicate toPredicate(Root&lt;BasicCommunity&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) &#123; List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;(); if (!org.springframework.util.StringUtils.isEmpty(communityName)) &#123; predicates.add(cb.like(root.get(\"name\"), \"%\" + communityName + \"%\")); &#125; if (!org.springframework.util.StringUtils.isEmpty(communityIds)) &#123; String[] idsStr = communityIds.split(\",\"); List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(); for (String s : idsStr) &#123; if (!org.springframework.util.StringUtils.isEmpty(s)) &#123; try &#123; ids.add(Integer.parseInt(s)); &#125; catch (NumberFormatException e) &#123; EstateEdgeErrors.parameterError(\"communityName\"); &#125; &#125; &#125; if (ids.size() &gt; 0) &#123; predicates.add(root.get(\"id\").in(ids)); &#125; &#125; return query.where(predicates.toArray(new Predicate[predicates.size()])).getRestriction(); &#125; &#125;; &#125;","categories":[],"tags":[]}]}